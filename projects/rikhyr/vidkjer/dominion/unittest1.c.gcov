        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:* RR
        -:    3:* CS 362
        -:    4:* shuffle() Unit Test
        -:    5:*
        -:    6:* 1. Check against nonpositive amount of deck cards amount;
        -:    7:* 2. Check shuffle actually happens.
        -:    8:*
        -:    9:* Check for occasional changes of game state inbetween testing runs.
        -:   10:* Should return a message of deck change for the player 0.
        -:   11:* 
        -:   12:*/
        -:   13:
        -:   14:
        -:   15:#include "dominion.h"
        -:   16:#include "dominion_helpers.h"
        -:   17:#include <string.h>
        -:   18:#include <stdio.h>
        -:   19:#include <assert.h>
        -:   20:#include "rngs.h"
        -:   21:#include "compareStates.h"
        -:   22:#include <stdlib.h>
        -:   23:#include <time.h>
        -:   24:#include <math.h>
        -:   25:
function main called 1 returned 100% blocks executed 80%
        1:   26:int main() 
        -:   27:{
        1:   28:    SelectStream(1);
вызов    0 вернул 1
        1:   29:	PutSeed(-1);
вызов    0 вернул 1
        -:   30:    int i, j; // auxilliary  vars
        1:   31:    int numPlayer = 2; // setting minimal count of players
        1:   32:    int k[10] = {adventurer, gardens, smithy, village, sea_hag, treasure_map, outpost, cutpurse, tribute, salvager};
        -:   33:    struct gameState G, copyG;
        1:   34:    int seed = floor(Random() * 1000);
вызов    0 вернул 1
        -:   35:
        1:   36:    srand(time(NULL));
вызов    0 вернул 1
вызов    1 вернул 1
        1:   37:    printf ("\nTESTING shuffle():\n");
вызов    0 вернул 1
        -:   38:    
        -:   39:	
        1:   40:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   41:    i = initializeGame(numPlayer, k, seed, &G); // initialize a new game
вызов    0 вернул 1
        1:   42:    memcpy(&copyG, &G, sizeof(struct gameState)); // save the game state before we start checking isGameOver
        -:   43:	// test if shuffle returns -1 if we set count of cards to 0
        -:   44:	//locVal=G.deckCount[0]; //should be 10 after game initialization
        1:   45:	G.deckCount[0]=0;
        1:   46:	printf("Force first player deck count to be 0 to see if shuffle() returns -1.\n");
вызов    0 вернул 1
        1:   47:    if (shuffle(0, &G) != -1)
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
        -:   48:    {
    #####:   49:        printf("Deck card amount is 0, but shuffle() was not -1.\n");
вызов   0 ни разу не исполнялся
        -:   50:    }
        1:   51:    printf("Running 1000 random tests for first player deck count to verify shuffle is -1 when deck amount is 0.\n");
вызов    0 вернул 1
     1001:   52:    for (i = 0; i < 1000; i++)
переход  0 выполнен 1000
переход  1 выполнен 1 (fallthrough)
        -:   53:    {
     1000:   54:        int localDeck = rand() % numPlayer;
вызов    0 вернул 1000
     1000:   55:        G.deckCount[0] = localDeck;
     1000:   56:        if (localDeck == 0)
переход  0 выполнен 508 (fallthrough)
переход  1 выполнен 492
        -:   57:        {
      508:   58:            if (shuffle(0,&G) != -1)
вызов    0 вернул 508
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 508
        -:   59:            {
    #####:   60:                printf("Test %d: Deck card amount is 0, but shuffle() was not -1.\n",i);
вызов   0 ни разу не исполнялся
        -:   61:            }
        -:   62:        }
        -:   63:    }
        1:   64:    printf("Done with deck card amount random testing.\n");
вызов    0 вернул 1
        -:   65:	
        1:   66:	G.deckCount[0]=10;
        1:   67:	G.deck[0][0]=curse;
        1:   68:	G.deck[0][1]=estate;
        1:   69:	G.deck[0][2]=duchy;
        1:   70:	G.deck[0][3]=province;
        1:   71:	G.deck[0][4]=copper;
        1:   72:	G.deck[0][5]=silver;
        1:   73:	G.deck[0][6]=gold;
        1:   74:	G.deck[0][7]=adventurer;
        1:   75:	G.deck[0][8]=smithy;
        1:   76:	G.deck[0][9]=gardens;
        -:   77:	
        1:   78:    printf("Running 10000 random tests for deck to see if we can detect when the shuffle is not performing correctly.\n");
вызов    0 вернул 1
        -:   79:   
        -:   80:   
        -:   81:   
    10001:   82:    for (i = 0; i < 10000; i++)
переход  0 выполнен 10000
переход  1 выполнен 1 (fallthrough)
        -:   83:    {
    10000:   84:        if (shuffle(0,&G)==-1)
вызов    0 вернул 10000
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 10000
        -:   85:		{
    #####:   86:			printf("Test %d failed: returned negative value on normal deck\n",i);
вызов   0 ни разу не исполнялся
        -:   87:		}
        -:   88:		else
        -:   89:		{
    10000:   90:			if ((G.deck[0][0]==curse)&&(G.deck[0][1]==estate)&&(G.deck[0][2]==duchy)&&(G.deck[0][3]==province)&&(G.deck[0][4]==copper)&&
переход  0 выполнен 1005 (fallthrough)
переход  1 выполнен 8995
переход  2 выполнен 124 (fallthrough)
переход  3 выполнен 881
переход  4 выполнен 12 (fallthrough)
переход  5 выполнен 112
переход  6 выполнен 1 (fallthrough)
переход  7 выполнен 11
переход  8 выполнен 0 (fallthrough)
переход  9 выполнен 1
переход 10 ни разу не исполнялся
переход 11 ни разу не исполнялся
    #####:   91:			(G.deck[0][5]==silver)&&(G.deck[0][6]==gold)&&(G.deck[0][7]==adventurer)&&(G.deck[0][8]==smithy)&&(G.deck[0][9]==gardens))
переход  0 ни разу не исполнялся
переход  1 ни разу не исполнялся
переход  2 ни разу не исполнялся
переход  3 ни разу не исполнялся
переход  4 ни разу не исполнялся
переход  5 ни разу не исполнялся
переход  6 ни разу не исполнялся
переход  7 ни разу не исполнялся
        -:   92:			{
    #####:   93:				printf("Test %d returned unshuffled deck\n",i);
вызов   0 ни разу не исполнялся
        -:   94:			};
        -:   95:		
        -:   96:		};
        -:   97:    }
        3:   98:    for (j = 0; j < numPlayer; j++)
переход  0 выполнен 2
переход  1 выполнен 1 (fallthrough)
        -:   99:    {
        2:  100:        (cmpDeckCount(&G, &copyG, j)) ? printf("Deck Count has changed between copied and modified game state!\n"):printf("Deck Count untouched\n");
вызов    0 вернул 2
переход  1 выполнен 1 (fallthrough)
переход  2 выполнен 1
вызов    3 вернул 1
вызов    4 вернул 1
        -:  101:        
        2:  102:	(cmpDiscard(&G, &copyG, j)) ? printf("Discard deck has changed between copied and modified game state!\n"):printf("Discard deck untouched\n");
вызов    0 вернул 2
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 2
вызов   3 ни разу не исполнялся
вызов    4 вернул 2
        -:  103:		
        2:  104:    (cmpDiscardCount(&G, &copyG, j)) ? printf("Discard count has been changed between copied and modified game state!\n"):printf("Discard count untouched\n");
вызов    0 вернул 2
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 2
вызов   3 ни разу не исполнялся
вызов    4 вернул 2
        -:  105:        
        2:  106:	(cmpDeck(&G, &copyG, j)) ? printf("Deck has changed between copied and modified game state!\n"): printf("Deck untouched\n");
вызов    0 вернул 2
переход  1 выполнен 1 (fallthrough)
переход  2 выполнен 1
вызов    3 вернул 1
вызов    4 вернул 1
        -:  107:		//This message should appear because we changed decks
        -:  108:    }
        1:  109:    printf("Testing general game state variables if they've been changed ...\n");
вызов    0 вернул 1
        1:  110:    printf("This will test to see if our copied game state before we performed shuffle testing is equal to the modified game state.\n");
вызов    0 вернул 1
        -:  111:    
        1:  112:    (cmpPlayedCards(&G, &copyG)) ? printf("PlayedCards has changed between copied and modified game state!\n"): printf("PlayedCards untouched!\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  113:    (cmpPlayedCardCount(&G, &copyG)) ? printf("playedCardCount has changed between copied and modified game state!\n"): printf("PlayedCardsCount untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  114:    (cmpPhase(&G, &copyG)) ? printf("phase has changed between copied and modified game state!\n"):printf("phase untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  115:    (cmpWhoseTurn(&G, &copyG)) ? printf("WhoseTurn has changed between copied and modified game state!\n"):printf("WhooseTurn untouched\n"); 
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  116:    (cmpNumActions(&G, &copyG)) ? printf("numActions has changed between copied and modified game state!\n"):printf("numActions untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  117:    (cmpOutpostPlayed(&G, &copyG)) ? printf("OutpostPlayed has changed between copied and modified game state!\n"):printf("OutpostPlayed untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  118:    (cmpNumPlayers(&G, &copyG)) ? printf("NumPlayers has changed between copied and modified game state!\n"):printf("NumPlayers untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  119:    (cmpNumBuys(&G, &copyG)) ? printf("NumBuys has changed between copied and modified game state!\n"):printf("NumBuys untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  120:    (cmpOutpostTurn(&G, &copyG)) ? printf("OutpostTurn has changed between copied and modified game state!\n"):printf("OutpostTurn untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:  121:    printf("Done checking game states.\n");
вызов    0 вернул 1
        1:  122:    printf("\nAll tests done for shuffle()!\n \n");
вызов    0 вернул 1
        1:  123:    return 0;
        -:  124:}
