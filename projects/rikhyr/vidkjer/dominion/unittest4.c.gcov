        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:* RR
        -:    3:* CS 362
        -:    4:* getCost() Unit Test
        -:    5:*
        -:    6:* 1. Check correct cards cost processing.
        -:    7:*
        -:    8:* Check for occasional changes of game state inbetween testing runs.
        -:    9:* 
        -:   10:* 
        -:   11:*/
        -:   12:
        -:   13:
        -:   14:#include "dominion.h"
        -:   15:#include "dominion_helpers.h"
        -:   16:#include <string.h>
        -:   17:#include <stdio.h>
        -:   18:#include <assert.h>
        -:   19:#include "rngs.h"
        -:   20:#include "compareStates.h"
        -:   21:#include <stdlib.h>
        -:   22:#include <time.h>
        -:   23:#include <math.h>
        -:   24:
function main called 1 returned 100% blocks executed 81%
        1:   25:int main() 
        -:   26:{
        1:   27:    SelectStream(1);
вызов    0 вернул 1
        1:   28:	PutSeed(-1);
вызов    0 вернул 1
        -:   29:    int i, j, zeros; // auxilliary  vars
        1:   30:    int numPlayer = 4; // setting maximal count of players
        1:   31:    int k[10] = {adventurer, gardens, smithy, village, sea_hag, treasure_map, outpost, cutpurse, tribute, salvager};
        -:   32:    struct gameState G, copyG;
        1:   33:    int seed = floor(Random() * 1000);
вызов    0 вернул 1
        1:   34:	int costs[27]={0,2,5,8,0,3,6,6,5,4,4,5,4,4,3,4,3,5,3,5,3,4,2,5,4,4,4};
        1:   35:    srand(time(NULL));
вызов    0 вернул 1
вызов    1 вернул 1
        1:   36:    printf ("\nTESTING getCost():\n");
вызов    0 вернул 1
        -:   37:    
        -:   38:	
        1:   39:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   40:    zeros = initializeGame(numPlayer, k, seed, &G); // initialize a new game
вызов    0 вернул 1
        1:   41:    memcpy(&copyG, &G, sizeof(struct gameState)); // save the game state before we start checking isGameOver
        -:   42:	
        1:   43:    printf("Running 1000 random tests for checking cards values to verify getCost() is showing correct amount.\n");
вызов    0 вернул 1
     1001:   44:    for (i = 0; i < 1000; i++)
переход  0 выполнен 1000
переход  1 выполнен 1 (fallthrough)
        -:   45:    {
     1000:   46:        int localDeck = rand() % 26;
вызов    0 вернул 1000
        -:   47:        
     1000:   48:		zeros=getCost(localDeck);
вызов    0 вернул 1000
     1000:   49:        if ((zeros<0)||(zeros>26))
переход  0 выполнен 1000 (fallthrough)
переход  1 выполнен 0
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 1000
        -:   50:        {
    #####:   51:			printf("Test %d. Value should be %d, but getCost() returned value out of allowed range: %d.\n",i,localDeck,zeros);
вызов   0 ни разу не исполнялся
        -:   52:		}
        -:   53:		
     1000:   54:        if (zeros != costs[localDeck])
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1000
        -:   55:        {
    #####:   56:            printf("Test %d - getCost() failed to get correct amount: %d instead of %d.\n",i,zeros,localDeck);
вызов   0 ни разу не исполнялся
        -:   57:        }
        -:   58:        
        -:   59:    }
        1:   60:    printf("Done with  random testing.\n");
вызов    0 вернул 1
        -:   61:	
        -:   62:	   
        5:   63:    for (j = 0; j < numPlayer; j++)
переход  0 выполнен 4
переход  1 выполнен 1 (fallthrough)
        -:   64:    {
        4:   65:    (cmpDeckCount(&G, &copyG, j)) ? printf("Deck Count has changed between copied and modified game state!\n"):printf("Deck Count untouched\n");
вызов    0 вернул 4
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 4
вызов   3 ни разу не исполнялся
вызов    4 вернул 4
        -:   66:        
        4:   67:	(cmpDiscard(&G, &copyG, j)) ? printf("Discard deck has changed between copied and modified game state!\n"):printf("Discard deck untouched\n");
вызов    0 вернул 4
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 4
вызов   3 ни разу не исполнялся
вызов    4 вернул 4
        -:   68:		
        4:   69:    (cmpDiscardCount(&G, &copyG, j)) ? printf("Discard count has been changed between copied and modified game state!\n"):printf("Discard count untouched\n");
вызов    0 вернул 4
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 4
вызов   3 ни разу не исполнялся
вызов    4 вернул 4
        -:   70:        
        4:   71:	(cmpDeck(&G, &copyG, j)) ? printf("Deck has changed between copied and modified game state!\n"): printf("Deck untouched\n");
вызов    0 вернул 4
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 4
вызов   3 ни разу не исполнялся
вызов    4 вернул 4
        -:   72:	
        -:   73:    }
        1:   74:    printf("Testing general game state variables if they've been changed ...\n");
вызов    0 вернул 1
        1:   75:    printf("This will test to see if our copied game state before we performed shuffle testing is equal to the modified game state.\n");
вызов    0 вернул 1
        -:   76:    
        1:   77:    (cmpPlayedCards(&G, &copyG)) ? printf("PlayedCards has changed between copied and modified game state!\n"): printf("PlayedCards untouched!\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   78:    (cmpPlayedCardCount(&G, &copyG)) ? printf("playedCardCount has changed between copied and modified game state!\n"): printf("PlayedCardsCount untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   79:    (cmpPhase(&G, &copyG)) ? printf("phase has changed between copied and modified game state!\n"):printf("phase untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   80:    (cmpWhoseTurn(&G, &copyG)) ? printf("WhoseTurn has changed between copied and modified game state!\n"):printf("WhooseTurn untouched\n"); 
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   81:    (cmpNumActions(&G, &copyG)) ? printf("numActions has changed between copied and modified game state!\n"):printf("numActions untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   82:    (cmpOutpostPlayed(&G, &copyG)) ? printf("OutpostPlayed has changed between copied and modified game state!\n"):printf("OutpostPlayed untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   83:    (cmpNumPlayers(&G, &copyG)) ? printf("NumPlayers has changed between copied and modified game state!\n"):printf("NumPlayers untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   84:    (cmpNumBuys(&G, &copyG)) ? printf("NumBuys has changed between copied and modified game state!\n"):printf("NumBuys untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   85:    (cmpOutpostTurn(&G, &copyG)) ? printf("OutpostTurn has changed between copied and modified game state!\n"):printf("OutpostTurn untouched\n");
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
вызов   3 ни разу не исполнялся
вызов    4 вернул 1
        1:   86:    printf("Done checking game states.\n");
вызов    0 вернул 1
        1:   87:    printf("\nAll tests done for getCost()!\n\n");
вызов    0 вернул 1
        1:   88:    return 0;
        -:   89:}
